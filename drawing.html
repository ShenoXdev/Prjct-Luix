<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: #222;
      font-family: Arial, sans-serif;
    }
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      padding: 8px;
      background: rgba(40, 40, 40, 0.9);
      z-index: 100;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .toolbar button {
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      min-width: 60px;
    }
    .toolbar input[type="number"] {
      width: 60px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
    }
    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: none;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      touch-action: none;
    }
    #zoomInfo {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    #controlsInfo {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    #fileInput {
      display: none;
    }
    @media (max-width: 768px) {
      #controlsInfo {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="zoomInfo">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: 1x</div>
  <div id="controlsInfo">
    ØªØ­ÙƒÙ…Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­: <br>
    WASD: Ø­Ø±ÙƒØ© | Q/E: ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± | B: ÙØ±Ø´Ø§Ø© | X: Ù…Ù…Ø­Ø§Ø©<br>
    1/2/3: Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ÙØ±Ø´Ø§Ø© | Space: ØªØ­Ø±ÙŠÙƒ | Ctrl+Z/Y: ØªØ±Ø§Ø¬Ø¹/Ø¥Ø¹Ø§Ø¯Ø©
  </div>

  <canvas id="canvas"></canvas>

  <div class="toolbar">
    <button onclick="setTool('brush')">âœï¸ ÙØ±Ø´Ø§Ø©</button>
    <button onclick="setTool('eraser')">ğŸ§½ Ù…Ù…Ø­Ø§Ø©</button>
    <input type="color" id="colorPicker" value="#000000" onchange="changeColor(this.value)">
    <input type="number" id="sizeInput" min="1" value="5" step="1">
    <button onclick="undo()">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
    <button onclick="redo()">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button onclick="clearCanvas()">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
    <button onclick="save()">ğŸ’¾ Ø­ÙØ¸</button>
    <button onclick="openFileDialog()">ğŸ“‚ ÙØªØ­</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeInput = document.getElementById("sizeInput");
    const colorPicker = document.getElementById("colorPicker");
    const zoomInfo = document.getElementById("zoomInfo");
    const fileInput = document.getElementById("fileInput");

    let tool = "brush";
    let drawing = false;
    let baseBrushSize = parseInt(sizeInput.value);
    let brushColor = colorPicker.value;
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let paths = [];
    let history = [];
    let historyIndex = -1;
    let currentPath = [];
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    const keys = {};
    const PAN_SPEED = 10;
    const ZOOM_SPEED = 0.05;
    const MIN_ZOOM = 0.000000000000000000000001;
    const MAX_ZOOM = 1000000;

    function init() {
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      fileInput.addEventListener("change", handleFileSelect);
      setupEventListeners();
      animationLoop();
      saveHistory();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    function setupEventListeners() {
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.ctrlKey && e.key === 'z') undo();
        if (e.ctrlKey && e.key === 'y') redo();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("wheel", handleWheel, { passive: false });

      // âœ… Ù„Ù…Ø³
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);

      sizeInput.addEventListener("input", () => {
        baseBrushSize = parseInt(sizeInput.value);
      });
    }

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }

    function handleTouchStart(e) {
      if (e.touches.length === 1) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        startDraw(pos.x, pos.y);
      } else if (e.touches.length === 2) {
        isPanning = true;
        panStart = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
      }
    }

    function handleTouchMove(e) {
      if (e.touches.length === 1 && !isPanning) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        draw(pos.x, pos.y);
      } else if (e.touches.length === 2) {
        const now = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2
        };
        offsetX += now.x - panStart.x;
        offsetY += now.y - panStart.y;
        panStart = now;
        redraw();
      }
    }

    function handleTouchEnd(e) {
      if (drawing) endDraw();
      if (e.touches.length < 2) isPanning = false;
    }

    function handleMouseDown(e) {
      if (e.button === 1 || e.ctrlKey) {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
      } else {
        startDraw(e.clientX, e.clientY);
      }
    }

    function handleMouseMove(e) {
      if (isPanning) {
        offsetX += e.clientX - panStart.x;
        offsetY += e.clientY - panStart.y;
        panStart = { x: e.clientX, y: e.clientY };
        redraw();
      } else {
        draw(e.clientX, e.clientY);
      }
    }

    function handleMouseUp(e) {
      if (isPanning) {
        isPanning = false;
      } else {
        endDraw();
      }
    }

    function handleWheel(e) {
      e.preventDefault();
      const zoomFactor = Math.exp(-e.deltaY * 0.001);
      const rect = canvas.getBoundingClientRect();
      handleZoom(e.clientX - rect.left, e.clientY - rect.top, zoomFactor);
    }

    function handleZoom(centerX, centerY, zoomFactor) {
      const wx = (centerX - offsetX) / scale;
      const wy = (centerY - offsetY) / scale;
      scale *= zoomFactor;
      scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
      offsetX = centerX - wx * scale;
      offsetY = centerY - wy * scale;
      updateZoomInfo();
      redraw();
    }

    function setTool(t) { tool = t; }
    function changeColor(color) { brushColor = color; }
    function screenToWorld(x, y) { return [(x - offsetX) / scale, (y - offsetY) / scale]; }
    function worldToScreen(x, y) { return [x * scale + offsetX, y * scale + offsetY]; }
    function getCurrentBrushSize() { return baseBrushSize / Math.sqrt(scale); }

    function startDraw(x, y) {
      if (isPanning) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }

    function draw(x, y) {
      if (!drawing || isPanning) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      redraw();
    }

    function endDraw() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
        saveHistory();
      }
      drawing = false;
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const path of paths) {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
      if (drawing && currentPath.length > 0) {
        ctx.beginPath();
        for (let i = 0; i < currentPath.length; i++) {
          const p = currentPath[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
    }

    function updateZoomInfo() {
      zoomInfo.textContent = `Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: ${scale.toFixed(2)}x`;
    }

    function saveHistory() {
      history.splice(historyIndex + 1);
      history.push(JSON.stringify({
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      }));
      historyIndex++;
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadStateFromHistory();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadStateFromHistory();
      }
    }

    function loadStateFromHistory() {
      try {
        const state = JSON.parse(history[historyIndex]);
        paths = state.paths || [];
        offsetX = state.camera?.offsetX || 0;
        offsetY = state.camera?.offsetY || 0;
        scale = state.camera?.scale || 1;
        if (state.brush) {
          baseBrushSize = state.brush.baseBrushSize || 5;
          brushColor = state.brush.brushColor || "#000000";
          colorPicker.value = brushColor;
          sizeInput.value = baseBrushSize;
        }
        redraw();
        updateZoomInfo();
      } catch (error) {
        console.error("Error loading state:", error);
      }
    }

    function clearCanvas() {
      if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŸ")) {
        paths = [];
        saveHistory();
        redraw();
      }
    }

    function save() {
      const data = {
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement("a");
      link.download = `Ø±Ø³Ù…Ø©-${new Date().toISOString().slice(0, 19)}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }

    function openFileDialog() {
      fileInput.click();
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data || !Array.isArray(data.paths)) throw new Error("ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± ØµØ§Ù„Ø­");
          paths = JSON.parse(JSON.stringify(data.paths));
          offsetX = data.camera?.offsetX || 0;
          offsetY = data.camera?.offsetY || 0;
          scale = data.camera?.scale || 1;
          if (data.brush) {
            baseBrushSize = data.brush.baseBrushSize || 5;
            brushColor = data.brush.brushColor || "#000000";
            colorPicker.value = brushColor;
            sizeInput.value = baseBrushSize;
          }
          history = [JSON.stringify({
            paths: JSON.parse(JSON.stringify(paths)),
            camera: { offsetX, offsetY, scale },
            brush: { baseBrushSize, brushColor }
          })];
          historyIndex = 0;
          redraw();
          updateZoomInfo();
          alert("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­");
        } catch (error) {
          alert(`Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${error.message}`);
        }
      };
      reader.onerror = function() {
        alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù");
      };
      reader.readAsText(file);
    }

    init();
  </script>
</body>
</html>
