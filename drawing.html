<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: #222;
      font-family: Arial, sans-serif;
    }
    
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      padding: 8px;
      background: rgba(40, 40, 40, 0.9);
      z-index: 100;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .toolbar button {
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      min-width: 60px;
    }
    
    .toolbar input[type="number"] {
      width: 60px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
    }
    
    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: none;
    }
    
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      touch-action: none;
    }
    
    #zoomInfo {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    
    #controlsInfo {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    
    #fileInput {
      display: none;
    }
    
    @media (max-width: 768px) {
      #controlsInfo {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="zoomInfo">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: 1x</div>
  <div id="controlsInfo">
    ØªØ­ÙƒÙ…Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­: <br>
    WASD: Ø­Ø±ÙƒØ© | Q/E: ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± | B: ÙØ±Ø´Ø§Ø© | X: Ù…Ù…Ø­Ø§Ø©<br>
    1/2/3: Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ÙØ±Ø´Ø§Ø© | Space: ØªØ­Ø±ÙŠÙƒ | Ctrl+Z/Y: ØªØ±Ø§Ø¬Ø¹/Ø¥Ø¹Ø§Ø¯Ø©
  </div>
  
  <canvas id="canvas"></canvas>
  
  <div class="toolbar">
    <button onclick="setTool('brush')">âœï¸ ÙØ±Ø´Ø§Ø©</button>
    <button onclick="setTool('eraser')">ğŸ§½ Ù…Ù…Ø­Ø§Ø©</button>
    <input type="color" id="colorPicker" value="#000000" onchange="changeColor(this.value)">
    <input type="number" id="sizeInput" min="1" value="5" step="1">
    <button onclick="undo()">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
    <button onclick="redo()">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button onclick="clearCanvas()">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
    <button onclick="save()">ğŸ’¾ Ø­ÙØ¸</button>
    <button onclick="openFileDialog()">ğŸ“‚ ÙØªØ­</button>
    <input type="file" id="fileInput" accept=".json" style="display:none">
  </div>

  <script>
    // Ø§Ù„Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeInput = document.getElementById("sizeInput");
    const colorPicker = document.getElementById("colorPicker");
    const zoomInfo = document.getElementById("zoomInfo");
    const fileInput = document.getElementById("fileInput");
    
    // Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    let tool = "brush";
    let drawing = false;
    let baseBrushSize = parseInt(sizeInput.value);
    let brushColor = colorPicker.value;
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let paths = [];
    let history = [];
    let historyIndex = -1;
    let currentPath = [];
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    
    // ØªØ­ÙƒÙ…Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
    const keys = {};
    const PAN_SPEED = 10;
    const ZOOM_SPEED = 0.05;
    const MIN_ZOOM = 0.000000000000000000000001;
    const MAX_ZOOM = 1000000;

    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    function init() {
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      fileInput.addEventListener("change", handleFileSelect);
      setupEventListeners();
      animationLoop();
      saveHistory();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redraw();
    }

    function setupEventListeners() {
      // Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.ctrlKey) {
          if (e.key === 'z') undo();
          if (e.key === 'y') redo();
        }
      });
      
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      
      // Ø§Ù„ÙØ£Ø±Ø©
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("wheel", handleWheel, { passive: false });
      
      // Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª
      sizeInput.addEventListener("input", () => {
        baseBrushSize = parseInt(sizeInput.value);
      });
    }

    function handleKeyboardControls() {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Ø§Ù„Ø­Ø±ÙƒØ©
      if (keys['w'] || keys['arrowup']) offsetY -= PAN_SPEED / scale;
      if (keys['s'] || keys['arrowdown']) offsetY += PAN_SPEED / scale;
      if (keys['a'] || keys['arrowleft']) offsetX -= PAN_SPEED / scale;
      if (keys['d'] || keys['arrowright']) offsetX += PAN_SPEED / scale;
      
      // Ø§Ù„ØªÙƒØ¨ÙŠØ±/Ø§Ù„ØªØµØºÙŠØ±
      if (keys['q']) handleZoom(centerX, centerY, 1 - ZOOM_SPEED);
      if (keys['e']) handleZoom(centerX, centerY, 1 + ZOOM_SPEED);
      
      // Ø§Ù„Ø£Ø¯ÙˆØ§Øª
      if (keys['b']) setTool('brush');
      if (keys['x']) setTool('eraser');
      
      // Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ÙØ±Ø´Ø§Ø©
      if (keys['1']) baseBrushSize = 1;
      if (keys['2']) baseBrushSize = 5;
      if (keys['3']) baseBrushSize = 10;
      
      // Ø§Ù„ØªØ­Ø±ÙŠÙƒ
      isPanning = keys[' '];
      
      if (keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['q'] || keys['e']) {
        redraw();
      }
    }

    function animationLoop() {
      handleKeyboardControls();
      requestAnimationFrame(animationLoop);
    }

    function setTool(t) {
      tool = t;
    }
    
    function changeColor(color) {
      brushColor = color;
    }
    
    function screenToWorld(x, y) {
      return [(x - offsetX) / scale, (y - offsetY) / scale];
    }
    
    function worldToScreen(x, y) {
      return [x * scale + offsetX, y * scale + offsetY];
    }
    
    function getCurrentBrushSize() {
      return baseBrushSize / Math.sqrt(scale);
    }
    
    function handleMouseDown(e) {
      if (e.button === 1 || e.ctrlKey) {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
      } else {
        startDraw(e.clientX, e.clientY);
      }
    }
    
    function startDraw(x, y) {
      if (isPanning) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }
    
    function handleMouseMove(e) {
      if (isPanning) {
        offsetX += e.clientX - panStart.x;
        offsetY += e.clientY - panStart.y;
        panStart = { x: e.clientX, y: e.clientY };
        redraw();
      } else {
        draw(e.clientX, e.clientY);
      }
    }
    
    function draw(x, y) {
      if (!drawing || isPanning) return;
      
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      
      redraw();
    }
    
    function handleMouseUp(e) {
      if (isPanning) {
        isPanning = false;
      } else {
        endDraw();
      }
    }
    
    function endDraw() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
        saveHistory();
      }
      drawing = false;
    }
    
    function handleWheel(e) {
      e.preventDefault();
      const zoomFactor = Math.exp(-e.deltaY * 0.001);
      const rect = canvas.getBoundingClientRect();
      handleZoom(e.clientX - rect.left, e.clientY - rect.top, zoomFactor);
    }
    
    function handleZoom(centerX, centerY, zoomFactor) {
      const wx = (centerX - offsetX) / scale;
      const wy = (centerY - offsetY) / scale;
      
      scale *= zoomFactor;
      scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
      
      offsetX = centerX - wx * scale;
      offsetY = centerY - wy * scale;
      
      updateZoomInfo();
      redraw();
    }
    
    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      for (const path of paths) {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
      
      if (drawing && currentPath.length > 0) {
        ctx.beginPath();
        for (let i = 0; i < currentPath.length; i++) {
          const p = currentPath[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          
          if (i === 0) ctx.moveTo(sx, sy);
          else ctx.lineTo(sx, sy);
        }
        ctx.stroke();
      }
    }
    
    function saveHistory() {
      history.splice(historyIndex + 1);
      history.push(JSON.stringify({
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      }));
      historyIndex++;
    }
    
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadStateFromHistory();
      }
    }
    
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadStateFromHistory();
      }
    }
    
    function loadStateFromHistory() {
      try {
        const state = JSON.parse(history[historyIndex]);
        paths = state.paths || [];
        offsetX = state.camera?.offsetX || 0;
        offsetY = state.camera?.offsetY || 0;
        scale = state.camera?.scale || 1;
        
        if (state.brush) {
          baseBrushSize = state.brush.baseBrushSize || 5;
          brushColor = state.brush.brushColor || "#000000";
          colorPicker.value = brushColor;
          sizeInput.value = baseBrushSize;
        }
        
        redraw();
        updateZoomInfo();
      } catch (error) {
        console.error("Error loading state:", error);
      }
    }
    
    function clearCanvas() {
      if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŸ")) {
        paths = [];
        saveHistory();
        redraw();
      }
    }
    
    function save() {
      const data = {
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement("a");
      link.download = `Ø±Ø³Ù…Ø©-${new Date().toISOString().slice(0, 19)}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }
    
    function openFileDialog() {
      fileInput.click();
    }
    
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          if (!data || !Array.isArray(data.paths)) {
            throw new Error("ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± ØµØ§Ù„Ø­");
          }
          
          paths = JSON.parse(JSON.stringify(data.paths));
          offsetX = data.camera?.offsetX || 0;
          offsetY = data.camera?.offsetY || 0;
          scale = data.camera?.scale || 1;
          
          if (data.brush) {
            baseBrushSize = data.brush.baseBrushSize || 5;
            brushColor = data.brush.brushColor || "#000000";
            colorPicker.value = brushColor;
            sizeInput.value = baseBrushSize;
          }
          
          history = [JSON.stringify({
            paths: JSON.parse(JSON.stringify(paths)),
            camera: { offsetX, offsetY, scale },
            brush: { baseBrushSize, brushColor }
          })];
          historyIndex = 0;
          
          redraw();
          updateZoomInfo();
          alert("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­");
        } catch (error) {
          alert(`Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${error.message}`);
          console.error("Error loading file:", error);
        }
      };
      
      reader.onerror = function() {
        alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù");
      };
      
      reader.readAsText(file);
    }
    
    function updateZoomInfo() {
      zoomInfo.textContent = `Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: ${scale.toFixed(2)}x`;
    }

    // Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    init();
  </script>
</body>
</html>