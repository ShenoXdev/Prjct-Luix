<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      background: #222;
      font-family: Arial, sans-serif;
    }
    .toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      padding: 8px;
      background: rgba(40, 40, 40, 0.9);
      z-index: 100;
      gap: 6px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .toolbar button {
      background: #444;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      font-size: 14px;
      min-width: 60px;
    }
    .toolbar input[type="number"] {
      width: 60px;
      background: #333;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px;
      text-align: center;
    }
    .toolbar input[type="color"] {
      width: 40px;
      height: 40px;
      border: none;
      background: none;
    }
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      touch-action: none;
    }
    #zoomInfo {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    #controlsInfo {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
    }
    #fileInput {
      display: none;
    }
    @media (max-width: 768px) {
      #controlsInfo {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div id="zoomInfo">Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: 1x</div>
  <div id="controlsInfo">
    ØªØ­ÙƒÙ…Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­: <br>
    WASD: Ø­Ø±ÙƒØ© | Q/E: ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ± | B: ÙØ±Ø´Ø§Ø© | X: Ù…Ù…Ø­Ø§Ø©<br>
    1/2/3: Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ÙØ±Ø´Ø§Ø© | Space: ØªØ­Ø±ÙŠÙƒ | Ctrl+Z/Y: ØªØ±Ø§Ø¬Ø¹/Ø¥Ø¹Ø§Ø¯Ø©
  </div>

  <canvas id="canvas"></canvas>

  <div class="toolbar">
    <button onclick="setTool('brush')">âœï¸ ÙØ±Ø´Ø§Ø©</button>
    <button onclick="setTool('eraser')">ğŸ§½ Ù…Ù…Ø­Ø§Ø©</button>
    <input type="color" id="colorPicker" value="#000000" onchange="changeColor(this.value)">
    <input type="number" id="sizeInput" min="1" value="5" step="1">
    <button onclick="undo()">â†©ï¸ ØªØ±Ø§Ø¬Ø¹</button>
    <button onclick="redo()">â†ªï¸ Ø¥Ø¹Ø§Ø¯Ø©</button>
    <button onclick="clearCanvas()">ğŸ—‘ï¸ Ù…Ø³Ø­</button>
    <button onclick="save()">ğŸ’¾ Ø­ÙØ¸</button>
    <button onclick="openFileDialog()">ğŸ“‚ ÙØªØ­</button>
    <input type="file" id="fileInput" accept=".json">
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    const sizeInput = document.getElementById("sizeInput");
    const colorPicker = document.getElementById("colorPicker");
    const zoomInfo = document.getElementById("zoomInfo");
    const fileInput = document.getElementById("fileInput");

    // ØªØ­Ø³ÙŠÙ† Ø¯Ù‚Ø© Ø§Ù„Ø±Ø³Ù…
    const dpr = window.devicePixelRatio || 1;
    
    let tool = "brush";
    let drawing = false;
    let baseBrushSize = parseInt(sizeInput.value);
    let brushColor = colorPicker.value;
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let paths = [];
    let history = [];
    let historyIndex = -1;
    let currentPath = [];
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    const keys = {};
    const PAN_SPEED = 10;
    const ZOOM_SPEED = 0.05;
    const MIN_ZOOM = 0.1;
    const MAX_ZOOM = 20;

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯
    let initialDistance = 0;
    let initialScale = 1;
    let initialOffsetX = 0;
    let initialOffsetY = 0;
    let initialMidpoint = { x: 0, y: 0 };
    let touchCount = 0;
    let lastSingleTouch = null;

    function init() {
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);
      fileInput.addEventListener("change", handleFileSelect);
      setupEventListeners();
      animationLoop();
      saveHistory();
    }

    function resizeCanvas() {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      // Ø¶Ø¨Ø· Ø¯Ù‚Ø© Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ø­Ø³Ø¨ ÙƒØ«Ø§ÙØ© Ø§Ù„Ø¨ÙƒØ³Ù„
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      
      ctx.scale(dpr, dpr);
      redraw();
    }

    function setupEventListeners() {
      window.addEventListener("keydown", (e) => {
        keys[e.key.toLowerCase()] = true;
        if (e.ctrlKey && e.key === 'z') undo();
        if (e.ctrlKey && e.key === 'y') redo();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      canvas.addEventListener("mousedown", handleMouseDown);
      canvas.addEventListener("mousemove", handleMouseMove);
      canvas.addEventListener("mouseup", handleMouseUp);
      canvas.addEventListener("wheel", handleWheel, { passive: false });

      // Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ù„Ù…Ø³
      canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
      canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
      canvas.addEventListener("touchend", handleTouchEnd);

      sizeInput.addEventListener("input", () => {
        baseBrushSize = parseInt(sizeInput.value);
      });
    }

    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (touch.clientX - rect.left) * dpr,
        y: (touch.clientY - rect.top) * dpr
      };
    }

    function calculateDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateMidpoint(touch1, touch2) {
      return {
        x: (touch1.clientX + touch2.clientX) / 2 * dpr,
        y: (touch1.clientY + touch2.clientY) / 2 * dpr
      };
    }

    function handleTouchStart(e) {
      touchCount = e.touches.length;
      
      if (touchCount === 1) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        lastSingleTouch = { x: pos.x, y: pos.y };
        startDraw(pos.x, pos.y);
      } else if (touchCount === 2) {
        e.preventDefault();
        // Ø¥Ù„ØºØ§Ø¡ Ø£ÙŠ Ø±Ø³Ù… Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ Ø¥ØµØ¨Ø¹ÙŠÙ†
        if (drawing) {
          endDraw();
          drawing = false;
        }
        
        initialDistance = calculateDistance(e.touches[0], e.touches[1]);
        initialScale = scale;
        initialOffsetX = offsetX;
        initialOffsetY = offsetY;
        initialMidpoint = calculateMidpoint(e.touches[0], e.touches[1]);
      }
    }

    function handleTouchMove(e) {
      touchCount = e.touches.length;
      
      if (touchCount === 1 && !isPanning) {
        e.preventDefault();
        const pos = getTouchPos(e.touches[0]);
        lastSingleTouch = { x: pos.x, y: pos.y };
        draw(pos.x, pos.y);
      } else if (touchCount === 2) {
        e.preventDefault();
        
        // Ù…Ù†Ø¹ Ø§Ù„Ø±Ø³Ù… Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ Ø¥ØµØ¨Ø¹ÙŠÙ†
        if (drawing) {
          endDraw();
          drawing = false;
        }
        
        const currentDistance = calculateDistance(e.touches[0], e.touches[1]);
        const currentMidpoint = calculateMidpoint(e.touches[0], e.touches[1]);
        
        // Ø§Ù„Ø²ÙˆÙ… Ø¹Ù†Ø¯ ØªØºÙŠØ± Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø£ØµØ§Ø¨Ø¹
        if (Math.abs(currentDistance - initialDistance) > 5) {
          const zoomFactor = currentDistance / initialDistance;
          scale = initialScale * zoomFactor;
          scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
          
          // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø²Ø§Ø­Ø© Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ
          const wx = (currentMidpoint.x - initialOffsetX) / initialScale;
          const wy = (currentMidpoint.y - initialOffsetY) / initialScale;
          offsetX = currentMidpoint.x - wx * scale;
          offsetY = currentMidpoint.y - wy * scale;
        } 
        // Ø§Ù„ØªØ­Ø±ÙŠÙƒ Ø¹Ù†Ø¯ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø£ØµØ§Ø¨Ø¹ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        else {
          offsetX = initialOffsetX + (currentMidpoint.x - initialMidpoint.x);
          offsetY = initialOffsetY + (currentMidpoint.y - initialMidpoint.y);
        }
        
        updateZoomInfo();
        redraw();
      }
    }

    function handleTouchEnd(e) {
      if (touchCount === 1 && drawing) {
        endDraw();
      }
      touchCount = e.touches.length;
      
      // Ø¥Ø°Ø§ Ø¨Ù‚ÙŠ Ø¥ØµØ¨Ø¹ ÙˆØ§Ø­Ø¯ Ø¨Ø¹Ø¯ Ø±ÙØ¹ Ø£Ø­Ø¯ Ø§Ù„Ø£ØµØ§Ø¨Ø¹
      if (touchCount === 1 && lastSingleTouch) {
        startDraw(lastSingleTouch.x, lastSingleTouch.y);
      }
    }

    function handleMouseDown(e) {
      if (e.button === 1 || e.ctrlKey) {
        isPanning = true;
        panStart = { x: e.clientX * dpr, y: e.clientY * dpr };
      } else {
        startDraw(e.clientX * dpr, e.clientY * dpr);
      }
    }

    function handleMouseMove(e) {
      if (isPanning) {
        offsetX += (e.clientX * dpr - panStart.x);
        offsetY += (e.clientY * dpr - panStart.y);
        panStart = { x: e.clientX * dpr, y: e.clientY * dpr };
        redraw();
      } else {
        draw(e.clientX * dpr, e.clientY * dpr);
      }
    }

    function handleMouseUp(e) {
      if (isPanning) {
        isPanning = false;
      } else {
        endDraw();
      }
    }

    function handleWheel(e) {
      e.preventDefault();
      const zoomFactor = Math.exp(-e.deltaY * 0.001);
      const rect = canvas.getBoundingClientRect();
      handleZoom(e.clientX * dpr - rect.left, e.clientY * dpr - rect.top, zoomFactor);
    }

    function handleZoom(centerX, centerY, zoomFactor) {
      const wx = (centerX - offsetX) / scale;
      const wy = (centerY - offsetY) / scale;
      scale *= zoomFactor;
      scale = Math.max(MIN_ZOOM, Math.min(scale, MAX_ZOOM));
      offsetX = centerX - wx * scale;
      offsetY = centerY - wy * scale;
      updateZoomInfo();
      redraw();
    }

    function setTool(t) { tool = t; }
    function changeColor(color) { brushColor = color; }
    function screenToWorld(x, y) { return [(x - offsetX) / scale, (y - offsetY) / scale]; }
    function worldToScreen(x, y) { return [x * scale + offsetX, y * scale + offsetY]; }
    function getCurrentBrushSize() { return baseBrushSize / Math.sqrt(scale); }

    function startDraw(x, y) {
      if (isPanning || touchCount > 1) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath = [{
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      }];
      drawing = true;
    }

    function draw(x, y) {
      if (!drawing || isPanning || touchCount > 1) return;
      const [wx, wy] = screenToWorld(x, y);
      currentPath.push({
        x: wx,
        y: wy,
        tool,
        size: getCurrentBrushSize(),
        color: tool === "brush" ? brushColor : "white"
      });
      redraw();
    }

    function endDraw() {
      if (drawing && currentPath.length > 1) {
        paths.push(currentPath);
        saveHistory();
      }
      drawing = false;
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.scale(dpr, dpr);
      
      for (const path of paths) {
        ctx.beginPath();
        for (let i = 0; i < path.length; i++) {
          const p = path[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale / dpr; // ØªØ¹Ø¯ÙŠÙ„ Ø­Ø¬Ù… Ø§Ù„ÙØ±Ø´Ø§Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¯Ù‚Ø©
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx / dpr, sy / dpr);
          else ctx.lineTo(sx / dpr, sy / dpr);
        }
        ctx.stroke();
      }
      
      if (drawing && currentPath.length > 0) {
        ctx.beginPath();
        for (let i = 0; i < currentPath.length; i++) {
          const p = currentPath[i];
          const [sx, sy] = worldToScreen(p.x, p.y);
          ctx.lineWidth = p.size * scale / dpr;
          ctx.strokeStyle = p.color;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          if (i === 0) ctx.moveTo(sx / dpr, sy / dpr);
          else ctx.lineTo(sx / dpr, sy / dpr);
        }
        ctx.stroke();
      }
      
      ctx.restore();
    }

    function updateZoomInfo() {
      zoomInfo.textContent = `Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙƒØ¨ÙŠØ±: ${scale.toFixed(2)}x`;
    }

    function saveHistory() {
      history.splice(historyIndex + 1);
      history.push(JSON.stringify({
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      }));
      historyIndex++;
    }

    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadStateFromHistory();
      }
    }

    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadStateFromHistory();
      }
    }

    function loadStateFromHistory() {
      try {
        const state = JSON.parse(history[historyIndex]);
        paths = state.paths || [];
        offsetX = state.camera?.offsetX || 0;
        offsetY = state.camera?.offsetY || 0;
        scale = state.camera?.scale || 1;
        if (state.brush) {
          baseBrushSize = state.brush.baseBrushSize || 5;
          brushColor = state.brush.brushColor || "#000000";
          colorPicker.value = brushColor;
          sizeInput.value = baseBrushSize;
        }
        redraw();
        updateZoomInfo();
      } catch (error) {
        console.error("Error loading state:", error);
      }
    }

    function clearCanvas() {
      if (confirm("Ù‡Ù„ ØªØ±ÙŠØ¯ Ù…Ø³Ø­ Ø§Ù„Ù„ÙˆØ­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ØŸ")) {
        paths = [];
        saveHistory();
        redraw();
      }
    }

    function save() {
      const data = {
        paths: JSON.parse(JSON.stringify(paths)),
        camera: { offsetX, offsetY, scale },
        brush: { baseBrushSize, brushColor }
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const link = document.createElement("a");
      link.download = `Ø±Ø³Ù…Ø©-${new Date().toISOString().slice(0, 19)}.json`;
      link.href = URL.createObjectURL(blob);
      link.click();
    }

    function openFileDialog() {
      fileInput.click();
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data || !Array.isArray(data.paths)) throw new Error("ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± ØµØ§Ù„Ø­");
          paths = JSON.parse(JSON.stringify(data.paths));
          offsetX = data.camera?.offsetX || 0;
          offsetY = data.camera?.offsetY || 0;
          scale = data.camera?.scale || 1;
          if (data.brush) {
            baseBrushSize = data.brush.baseBrushSize || 5;
            brushColor = data.brush.brushColor || "#000000";
            colorPicker.value = brushColor;
            sizeInput.value = baseBrushSize;
          }
          history = [JSON.stringify({
            paths: JSON.parse(JSON.stringify(paths)),
            camera: { offsetX, offsetY, scale },
            brush: { baseBrushSize, brushColor }
          })];
          historyIndex = 0;
          redraw();
          updateZoomInfo();
          alert("ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… Ø¨Ù†Ø¬Ø§Ø­");
        } catch (error) {
          alert(`Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${error.message}`);
        }
      };
      reader.onerror = function() {
        alert("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù");
      };
      reader.readAsText(file);
    }

    function animationLoop() {
      // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
      if (keys['w'] || keys['arrowup']) offsetY += PAN_SPEED;
      if (keys['s'] || keys['arrowdown']) offsetY -= PAN_SPEED;
      if (keys['a'] || keys['arrowleft']) offsetX += PAN_SPEED;
      if (keys['d'] || keys['arrowright']) offsetX -= PAN_SPEED;
      if (keys['q']) handleZoom(canvas.width/2, canvas.height/2, 1 + ZOOM_SPEED);
      if (keys['e']) handleZoom(canvas.width/2, canvas.height/2, 1 - ZOOM_SPEED);
      if (keys['b']) setTool('brush');
      if (keys['x']) setTool('eraser');
      if (keys['1']) baseBrushSize = 5;
      if (keys['2']) baseBrushSize = 10;
      if (keys['3']) baseBrushSize = 20;
      
      if (keys['w'] || keys['s'] || keys['a'] || keys['d'] || 
          keys['q'] || keys['e'] || keys['arrowup'] || keys['arrowdown'] || 
          keys['arrowleft'] || keys['arrowright']) {
        redraw();
        updateZoomInfo();
      }
      
      requestAnimationFrame(animationLoop);
    }

    init();
  </script>
</body>
</html>
