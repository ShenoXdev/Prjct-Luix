<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ù…Ø¹ Ø£Ø¯ÙˆØ§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; touch-action: none; font-family: sans-serif;
  }
  #menu {
    position: fixed;
    top: 0; right: 0; left: 0;
    background: #f0f0f0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    z-index: 20;
  }
  canvas {
    position: absolute;
    top: 50px; left: 0;
    width: 100%;
    height: calc(100% - 50px);
    background: white;
    touch-action: none;
  }
  .zoom-info {
    position: fixed;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 30;
  }
  #toolDropdown {
    position: relative;
  }
  #toolDropdownContent {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border: 1px solid #ccc;
    border-radius: 5px;
    min-width: 160px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    z-index: 50;
  }
  #toolDropdownContent button {
    width: 100%;
    border: none;
    background: none;
    padding: 8px 12px;
    text-align: right;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  #toolDropdownContent button:hover {
    background-color: #eee;
  }
  #menu button, #menu label {
    font-size: 20px;
    cursor: pointer;
    background: none;
    border: none;
    padding: 5px 8px;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #menu label {
    cursor: default;
  }
  #menu input[type="color"], #menu input[type="number"] {
    width: 40px;
    height: 30px;
    margin-left: 5px;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
</style>
</head>
<body>

<div id="menu">
  <label title="Ø§Ø®ØªØ± Ø§Ù„Ù„ÙˆÙ†">ğŸ¨<input type="color" id="colorPicker" value="#000000"></label>
  <label title="Ø­Ø¬Ù… Ø§Ù„ÙØ±Ø´Ø§Ø©">ğŸ–Œï¸<input type="number" id="brushSize" min="1" max="100" value="3" step="1"></label>
  <button id="undoBtn" title="ØªØ±Ø§Ø¬Ø¹">â†©ï¸</button>
  <button id="redoBtn" title="Ø¥Ø¹Ø§Ø¯Ø©">â†ªï¸</button>
  <button id="clearBtn" title="Ù…Ø³Ø­">ğŸ§¹</button>
  <button id="saveBtn" title="Ø­ÙØ¸ ØµÙˆØ±Ø©">ğŸ’¾</button>
  <button id="saveJsonBtn" title="Ø­ÙØ¸ JSON">ğŸ“</button>
  <button id="loadJsonBtn" title="ÙØªØ­ JSON">ğŸ“‚</button>
  
  <div id="toolDropdown">
    <button id="toggleToolList" title="Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù…">âš™ï¸</button>
    <div id="toolDropdownContent" role="menu" aria-hidden="true">
      <button data-tool="brush" title="ÙØ±Ø´Ø§Ø©">ğŸ–Œï¸ ÙØ±Ø´Ø§Ø©</button>
      <button data-tool="highlighter" title="Ù…Ø§Ø±ÙƒØ±">ğŸ¯ Ù…Ø§Ø±ÙƒØ±</button>
      <button data-tool="pencil" title="Ù‚Ù„Ù… Ø±ØµØ§Øµ">âœï¸ Ù‚Ù„Ù… Ø±ØµØ§Øµ</button>
      <button data-tool="fountainPen" title="Ù‚Ù„Ù… Ø­Ø¨Ø±">ğŸ–‹ï¸ Ù‚Ù„Ù… Ø­Ø¨Ø±</button>
      <button data-tool="airbrush" title="Ø¨Ø®Ø§Ø®">ğŸŒ«ï¸ Ø¨Ø®Ø§Ø®</button>
      <button data-tool="eraser" title="Ù…Ù…Ø­Ø§Ø©">ğŸ©¹ Ù…Ù…Ø­Ø§Ø©</button>
      <button data-tool="softEraser" title="Ù…Ù…Ø­Ø§Ø© Ù†Ø§Ø¹Ù…Ø©">ğŸ§½ Ù…Ù…Ø­Ø§Ø© Ù†Ø§Ø¹Ù…Ø©</button>
      <button data-tool="blender" title="Ù…Ù…Ø²Ø¬">ğŸ”„ Ù…Ø²Ø¬ Ø§Ù„Ø£Ù„ÙˆØ§Ù†</button>
      <button data-tool="fill" title="ØªØ¹Ø¨Ø¦Ø©">ğŸª£ ØªØ¹Ø¨Ø¦Ø©</button>
      <button data-tool="glowpen" title="Ù‚Ù„Ù… ØªÙˆÙ‡Ø¬">âœ¨ğŸ–Šï¸ Ù‚Ù„Ù… ØªÙˆÙ‡Ø¬</button>
      <button data-tool="pixelpen" title="Ù‚Ù„Ù… Ø¨ÙƒØ³Ù„">ğŸŸ¦ Ù‚Ù„Ù… Ø¨ÙƒØ³Ù„</button>
      <button data-tool="line" title="Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…">ğŸ“ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…</button>
    </div>
  </div>
</div>

<canvas id="canvas"></canvas>
<div class="zoom-info" id="zoomInfo">Ø²ÙˆÙ…: 1x</div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const colorPicker = document.getElementById("colorPicker");
  const brushSize = document.getElementById("brushSize");
  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const clearBtn = document.getElementById("clearBtn");
  const saveBtn = document.getElementById("saveBtn");
  const saveJsonBtn = document.getElementById("saveJsonBtn");
  const loadJsonBtn = document.getElementById("loadJsonBtn");
  const zoomInfo = document.getElementById("zoomInfo");
  const toggleToolList = document.getElementById("toggleToolList");
  const toolDropdownContent = document.getElementById("toolDropdownContent");

  const jsonFileInput = document.createElement("input");
  jsonFileInput.type = "file";
  jsonFileInput.accept = ".json";
  jsonFileInput.style.display = "none";
  document.body.appendChild(jsonFileInput);

  let width = window.innerWidth;
  let height = window.innerHeight - 50;
  canvas.width = width;
  canvas.height = height;

  let paths = [];
  let undonePaths = [];
  let currentPath = null;
  let drawing = false;
  let hasMoved = false;
  let lastX = 0;
  let lastY = 0;

  let zoom = 1;
  let panX = 0;
  let panY = 0;
  let isZooming = false;
  let lastTouchDist = 0;
  let zoomEndTime = 0;
  const ZOOM_COOLDOWN = 200;
  const MIN_ZOOM = 1e-25;
  const MAX_ZOOM = 1e25;

  let currentTool = "brush";

  // ÙØªØ­/ØºÙ„Ù‚ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª
  toggleToolList.addEventListener("click", () => {
    if (toolDropdownContent.style.display === "block") {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    } else {
      toolDropdownContent.style.display = "block";
      toolDropdownContent.setAttribute("aria-hidden", "false");
    }
  });

  // Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø®Ø§Ø±Ø¬Ù‡Ø§
  window.addEventListener("click", (e) => {
    if (!toggleToolList.contains(e.target) && !toolDropdownContent.contains(e.target)) {
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
    }
  });

  // ØªØºÙŠÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø© Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø±Ù‡Ø§
  toolDropdownContent.querySelectorAll("button").forEach(btn => {
    btn.addEventListener("click", () => {
      currentTool = btn.getAttribute("data-tool");
      toolDropdownContent.style.display = "none";
      toolDropdownContent.setAttribute("aria-hidden", "true");
      console.log("ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ø¯Ø§Ø©:", currentTool);
    });
  });

  // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ø²ÙˆÙ…
  function updateZoomInfo() {
    if (zoom < 0.0001 || zoom > 10000) {
      zoomInfo.textContent = `Ø²ÙˆÙ…: ${zoom.toExponential(2)}x`;
    } else {
      zoomInfo.textContent = `Ø²ÙˆÙ…: ${zoom.toFixed(zoom >= 1 ? 2 : 8)}x`;
    }
  }

  // Ù…Ø³Ø§Ø¹Ø¯Ø§Øª Ù„Ù„Ø£Ø¯ÙˆØ§Øª

  // Ø±Ø³Ù… Ø¨ÙƒØ³Ù„ (Ù…Ø±Ø¨Ø¹ ØµØºÙŠØ±)
  function drawPixel(x, y, size, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x - size/2, y - size/2, size, size);
  }

  // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¨Ø®Ø§Ø®
  function airbrushEffect(x, y, size, color) {
    const density = 15;
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.04;
    for(let i=0; i<density; i++) {
      const offsetX = (Math.random() - 0.5) * size * 2;
      const offsetY = (Math.random() - 0.5) * size * 2;
      ctx.beginPath();
      ctx.arc(x + offsetX, y + offsetY, size/5, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  // ØªØ£Ø«ÙŠØ± Ù…Ø²Ø¬ (blender)
  function blendEffect(x, y, size) {
    const gradient = ctx.createRadialGradient(x, y, size*0.3, x, y, size);
    gradient.addColorStop(0, 'rgba(255,255,255,0.7)');
    gradient.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  // ØªØ¹Ø¨Ø¦Ø© flood fill (Ù†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ© ÙˆÙ„ÙˆÙ†)
  function floodFill(startX, startY, fillColor) {
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imgData.data;
    const width = imgData.width;
    const height = imgData.height;

    function matchColor(x,y,color) {
      const index = (y * width + x) * 4;
      return (
        data[index] === color[0] &&
        data[index+1] === color[1] &&
        data[index+2] === color[2] &&
        data[index+3] === color[3]
      );
    }

    function setColor(x,y,color) {
      const index = (y * width + x) * 4;
      data[index] = color[0];
      data[index+1] = color[1];
      data[index+2] = color[2];
      data[index+3] = color[3];
    }

    const startPos = (Math.floor(startY) * width + Math.floor(startX)) * 4;
    const startColor = [data[startPos], data[startPos+1], data[startPos+2], data[startPos+3]];

    const fillColRGBA = hexToRgba(fillColor);

    if (arraysEqual(startColor, fillColRGBA)) return; 

    let stack = [[Math.floor(startX), Math.floor(startY)]];

    while(stack.length > 0) {
      const [x,y] = stack.pop();
      if(x < 0 || x >= width || y < 0 || y >= height) continue;
      if(matchColor(x,y,startColor)) {
        setColor(x,y,fillColRGBA);
        stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }

  function hexToRgba(hex) {
    hex = hex.replace('#','');
    if(hex.length === 3) {
      hex = hex.split('').map(c => c+c).join('');
    }
    const bigint = parseInt(hex,16);
    return [
      (bigint >> 16) & 255,
      (bigint >> 8) & 255,
      bigint & 255,
      255
    ];
  }
  function arraysEqual(a,b) {
    if(a.length !== b.length) return false;
    for(let i=0; i<a.length; i++) {
      if(a[i] !== b[i]) return false;
    }
    return true;
  }

  // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø¨Ø­Ø³Ø¨ Ø§Ù„Ø£Ø¯Ø§Ø©
  function drawPathSegment(lastX, lastY, pos) {
    switch(currentTool) {
      case "highlighter":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = currentPath.size * 3;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "pencil":
        ctx.strokeStyle = currentPath.color;
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = Math.max(1, currentPath.size / 3);
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.globalAlpha = 1;
        break;

      case "fountainPen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size * 1.5;
        ctx.lineCap = "round";
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 1;
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "airbrush":
        airbrushEffect(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "eraser":
        ctx.clearRect(pos.x - currentPath.size/2, pos.y - currentPath.size/2, currentPath.size, currentPath.size);
        break;

      case "softEraser":
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, currentPath.size/2, 0, Math.PI * 2);
        ctx.fill();
        break;

      case "blender":
        blendEffect(pos.x, pos.y, currentPath.size);
        break;

      case "glowpen":
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.shadowColor = currentPath.color;
        ctx.shadowBlur = 15;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
        break;

      case "pixelpen":
        drawPixel(pos.x, pos.y, currentPath.size, currentPath.color);
        break;

      case "line":
        // Ù„Ø§ ÙŠØ±Ø³Ù… Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨ØŒ Ø§Ù„Ø±Ø³Ù… ÙŠØªÙ… Ø¹Ù†Ø¯ Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ ÙÙ‚Ø·
        break;

      case "fill":
        // ØªØ¹Ø¨Ø¦Ø© Ø¨Ù„ÙˆÙ† Ø¹Ù†Ø¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¶ØºØ·
        floodFill(pos.x, pos.y, currentPath.color);
        break;

      default: // brush
        ctx.strokeStyle = currentPath.color;
        ctx.lineWidth = currentPath.size;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
    }
  }

  // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… ÙƒÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
  function drawAll() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.setTransform(zoom, 0, 0, zoom, panX, panY);

    for (let path of paths) {
      ctx.strokeStyle = path.color;
      ctx.lineWidth = path.size;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      if(path.tool === "line") {
        if(path.points.length >= 2) {
          ctx.beginPath();
          ctx.moveTo(path.points[0].x, path.points[0].y);
          ctx.lineTo(path.points[path.points.length-1].x, path.points[path.points.length-1].y);
          ctx.stroke();
        }
      } else if(path.tool === "pixelpen") {
        for(let pt of path.points) {
          drawPixel(pt.x, pt.y, path.size, path.color);
        }
      } else if(path.tool === "highlighter") {
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        for(let i=0; i<path.points.length-1; i++) {
          ctx.moveTo(path.points[i].x, path.points[i].y);
          ctx.lineTo(path.points[i+1].x, path.points[i+1].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else if(path.tool === "softEraser") {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        for(let pt of path.points) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, path.size/2, 0, Math.PI*2);
          ctx.fill();
        }
      } else if(path.tool === "blender") {
        for(let pt of path.points) {
          blendEffect(pt.x, pt.y, path.size);
        }
      } else if(path.tool === "airbrush") {
        for(let pt of path.points) {
          airbrushEffect(pt.x, pt.y, path.size, path.color);
        }
      } else if(path.tool === "eraser") {
        for(let pt of path.points) {
          ctx.clearRect(pt.x - path.size/2, pt.y - path.size/2, path.size, path.size);
        }
      } else if(path.tool === "fountainPen") {
        ctx.shadowColor = path.color;
        ctx.shadowBlur = 1;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size * 1.5;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else if(path.tool === "glowpen") {
        ctx.shadowColor = path.color;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else { // brush and pencil default
        ctx.globalAlpha = path.tool === "pencil" ? 0.6 : 1;
        ctx.beginPath();
        ctx.moveTo(path.points[0].x, path.points[0].y);
        for(let i=1; i<path.points.length; i++) {
          ctx.lineTo(path.points[i].x, path.points[i].y);
        }
        ctx.lineWidth = path.size;
        ctx.strokeStyle = path.color;
        ctx.lineCap = "round";
        ctx.stroke();
        ctx.globalAlpha = 1;
      }
    }
  }

  // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ø´Ø§Ø´Ø© Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù„ÙˆØ­Ø© Ù…Ø¹ Ø§Ù„Ø²ÙˆÙ… ÙˆØ§Ù„Ø¨Ø§Ù†
  function screenToCanvas(x, y) {
    return {
      x: (x - panX) / zoom,
      y: (y - panY) / zoom
    };
  }

  // Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…
  function startDrawing(x, y) {
    drawing = true;
    hasMoved = false;
    const pos = screenToCanvas(x, y);
    currentPath = {
      tool: currentTool,
      color: currentTool === "eraser" || currentTool === "softEraser" ? "#FFFFFF" : colorPicker.value,
      size: parseInt(brushSize.value),
      points: [pos]
    };

    if(currentTool === "fill") {
      floodFill(pos.x, pos.y, currentPath.color);
      drawing = false;
      currentPath = null;
      return;
    }

    if(currentTool === "line") {
      // ÙÙ‚Ø· ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
      currentPath.start = pos;
      currentPath.points = [pos, pos];
    }

    undonePaths = []; // Ù…Ø³Ø­ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø¹Ù†Ø¯ Ø±Ø³Ù… Ø¬Ø¯ÙŠØ¯
  }

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ù… Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø³Ø­Ø¨
  function moveDrawing(x, y) {
    if (!drawing) return;
    hasMoved = true;
    const pos = screenToCanvas(x, y);
    if(currentTool === "line") {
      currentPath.points[1] = pos; // ØªØ­Ø¯ÙŠØ« Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø®Ø·
      drawAll();
      // Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ ÙÙˆÙ‚
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      ctx.strokeStyle = currentPath.color;
      ctx.lineWidth = currentPath.size;
      ctx.beginPath();
      ctx.moveTo(currentPath.start.x, currentPath.start.y);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    } else {
      const last = currentPath.points[currentPath.points.length -1];
      currentPath.points.push(pos);
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      drawPathSegment(last.x, last.y, pos);
    }
  }

  // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø±Ø³Ù…
  function endDrawing(x, y) {
    if (!drawing) return;
    drawing = false;
    if(!hasMoved && currentTool !== "fill" && currentTool !== "line") {
      // Ø±Ø³Ù… Ù†Ù‚Ø·Ø© ÙˆØ§Ø­Ø¯Ø© Ù„Ùˆ Ù„Ù… ÙŠØªØ­Ø±Ùƒ Ø§Ù„Ø¥ØµØ¨Ø¹
      const pos = screenToCanvas(x, y);
      currentPath.points.push(pos);
      ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
      drawPathSegment(pos.x, pos.y, pos);
    }

    if(currentTool === "line" && currentPath.points.length === 2) {
      // ÙÙ‚Ø· Ù†Ø¶ÙŠÙ Ø®Ø· ÙƒØ§Ù…Ù„
      paths.push(currentPath);
      currentPath = null;
      drawAll();
      return;
    }

    if(currentPath && currentPath.points.length > 0) {
      paths.push(currentPath);
      currentPath = null;
      drawAll();
    }
  }

  // ØªØ±Ø§Ø¬Ø¹
  undoBtn.addEventListener("click", () => {
    if(paths.length > 0) {
      undonePaths.push(paths.pop());
      drawAll();
    }
  });

  // Ø¥Ø¹Ø§Ø¯Ø©
  redoBtn.addEventListener("click", () => {
    if(undonePaths.length > 0) {
      paths.push(undonePaths.pop());
      drawAll();
    }
  });

  // Ù…Ø³Ø­ Ø§Ù„ÙƒÙ„
  clearBtn.addEventListener("click", () => {
    paths = [];
    undonePaths = [];
    drawAll();
  });

  // Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø© PNG
  saveBtn.addEventListener("click", () => {
    const link = document.createElement("a");
    link.download = "drawing.png";
    link.href = canvas.toDataURL();
    link.click();
  });

  // Ø­ÙØ¸ JSON
  saveJsonBtn.addEventListener("click", () => {
    const dataStr = JSON.stringify(paths);
    const blob = new Blob([dataStr], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "drawing.json";
    a.click();
    URL.revokeObjectURL(url);
  });

  // ÙØªØ­ JSON
  loadJsonBtn.addEventListener("click", () => {
    jsonFileInput.click();
  });

  jsonFileInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const loadedPaths = JSON.parse(event.target.result);
        if(Array.isArray(loadedPaths)) {
          paths = loadedPaths;
          undonePaths = [];
          drawAll();
        }
      } catch(err) {
        alert("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù");
      }
    };
    reader.readAsText(file);
  });

  // Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³ / Ø§Ù„Ù„Ù…Ø³
  let pointerId = null;

  function pointerDown(e) {
    if(pointerId !== null) return; // ÙŠØ¯Ø¹Ù… Ø¥ØµØ¨Ø¹ ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· Ù„Ù„Ø±Ø³Ù…
    pointerId = e.pointerId;
    startDrawing(e.clientX, e.clientY);
  }
  function pointerMove(e) {
    if(e.pointerId !== pointerId) return;
    moveDrawing(e.clientX, e.clientY);
  }
  function pointerUp(e) {
    if(e.pointerId !== pointerId) return;
    pointerId = null;
    endDrawing(e.clientX, e.clientY);
  }

  canvas.addEventListener("pointerdown", pointerDown);
  canvas.addEventListener("pointermove", pointerMove);
  canvas.addEventListener("pointerup", pointerUp);
  canvas.addEventListener("pointercancel", pointerUp);
  canvas.addEventListener("pointerout", pointerUp);
  canvas.addEventListener("pointerleave", pointerUp);

  // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø²ÙˆÙ… (Ù„Ù…Ø³ Ø¨ØµØ¨Ø§Ø¹ÙŠÙ†) ÙˆØ§Ù„Ø¨Ø§Ù†
  canvas.addEventListener("touchmove", (e) => {
    if(e.touches.length === 2) {
      e.preventDefault();

      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);

      if(!isZooming) {
        isZooming = true;
        lastTouchDist = dist;
        return;
      }

      let delta = dist - lastTouchDist;
      const zoomFactor = 0.005;

      zoom += delta * zoomFactor;
      if (zoom < MIN_ZOOM) zoom = MIN_ZOOM;
      if (zoom > MAX_ZOOM) zoom = MAX_ZOOM;
      lastTouchDist = dist;

      // ØªØ­Ø¯ÙŠØ« Ù…Ø±ÙƒØ² Ø§Ù„Ø²ÙˆÙ… Ù„ÙŠÙƒÙˆÙ† Ù…Ø±ÙƒØ² Ø§Ù„Ù„Ù…Ø³
      const centerX = (t1.clientX + t2.clientX) / 2;
      const centerY = (t1.clientY + t2.clientY) / 2;

      panX += centerX * (1 - (zoom / (zoom - delta * zoomFactor)));
      panY += centerY * (1 - (zoom / (zoom - delta * zoomFactor)));

      drawAll();
      updateZoomInfo();
    }
  }, {passive: false});

  canvas.addEventListener("touchend", (e) => {
    if(e.touches.length < 2) {
      isZooming = false;
    }
  });

  // ØªØ­Ø¯ÙŠØ« Ø­Ø¬Ù… Ø§Ù„Ù„ÙˆØ­Ø© Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
  window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight - 50;
    canvas.width = width;
    canvas.height = height;
    drawAll();
  });

  updateZoomInfo();
  drawAll();
</script>

</body>
</html>
