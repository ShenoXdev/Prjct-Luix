<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ø±Ø³Ù… Ù…Ø¹ Ø²ÙˆÙ… Ø¨ØµØ¨Ø§Ø¹ÙŠÙ† ÙˆØ­ÙØ¸ JSON</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #f5f5f5;
  font-family: sans-serif;
}
canvas {
  background: white;
  display: block;
  touch-action: none;
}
.toolbar {
  position: fixed;
  top: 10px;
  left: 10px;
  display: flex;
  gap: 8px;
  z-index: 100;
}
button {
  padding: 8px 12px;
  border: none;
  border-radius: 6px;
  background: #333;
  color: white;
  font-size: 14px;
  cursor: pointer;
}
button:hover {
  background: #555;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="toolbar">
  <button id="save">ğŸ’¾ Ø­ÙØ¸</button>
  <button id="open">ğŸ“‚ ÙØªØ­</button>
  <button id="clear">ğŸ—‘ Ù…Ø³Ø­</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let zoom = 1;
let zoomMin = 0.0000000000000000000000001;
let zoomMax = 1000000000000000000000000;
let panX = 0, panY = 0;
let drawing = false;
let lastX, lastY;

let paths = []; // Ù†Ø®Ø²Ù† Ø§Ù„Ø±Ø³Ù… ÙƒÙ€ JSON
let currentPath = [];

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  redraw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function redraw() {
  ctx.setTransform(zoom, 0, 0, zoom, panX, panY);
  ctx.clearRect(-panX / zoom, -panY / zoom, canvas.width / zoom, canvas.height / zoom);
  
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  for (let path of paths) {
    ctx.strokeStyle = path.color;
    ctx.lineWidth = path.size;
    ctx.beginPath();
    ctx.moveTo(path.points[0].x, path.points[0].y);
    for (let p of path.points) {
      ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
  }
}

canvas.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  drawing = true;
  lastX = (e.clientX - panX) / zoom;
  lastY = (e.clientY - panY) / zoom;
  currentPath = { color: "#000", size: 2, points: [{x: lastX, y: lastY}] };
});
canvas.addEventListener('mousemove', e => {
  if (!drawing) return;
  let x = (e.clientX - panX) / zoom;
  let y = (e.clientY - panY) / zoom;
  currentPath.points.push({x, y});
  redraw();
  paths.push(currentPath);
});
canvas.addEventListener('mouseup', e => {
  if (drawing) {
    drawing = false;
    paths.push(currentPath);
  }
});

// Ù„Ù…Ø³ ÙˆØªØ­Ø±ÙŠÙƒ Ù…Ø¹ Ø²ÙˆÙ… Ø¨ØµØ¨Ø§Ø¹ÙŠÙ†
let touchStartDist = 0;
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    let touch = e.touches[0];
    drawing = true;
    lastX = (touch.clientX - panX) / zoom;
    lastY = (touch.clientY - panY) / zoom;
    currentPath = { color: "#000", size: 2, points: [{x: lastX, y: lastY}] };
  } else if (e.touches.length === 2) {
    drawing = false;
    touchStartDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (e.touches.length === 1 && drawing) {
    let touch = e.touches[0];
    let x = (touch.clientX - panX) / zoom;
    let y = (touch.clientY - panY) / zoom;
    currentPath.points.push({x, y});
    redraw();
    paths.push(currentPath);
  } else if (e.touches.length === 2) {
    let newDist = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    let scale = newDist / touchStartDist;
    zoom *= scale;
    zoom = Math.min(Math.max(zoom, zoomMin), zoomMax);
    touchStartDist = newDist;
    redraw();
  }
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (drawing) {
    drawing = false;
    paths.push(currentPath);
  }
});

// Ø­ÙØ¸ JSON
document.getElementById('save').addEventListener('click', () => {
  let blob = new Blob([JSON.stringify(paths)], {type: "application/json"});
  let url = URL.createObjectURL(blob);
  let a = document.createElement('a');
  a.href = url;
  a.download = "drawing.json";
  a.click();
  URL.revokeObjectURL(url);
});

// ÙØªØ­ JSON
document.getElementById('open').addEventListener('click', () => {
  let input = document.createElement('input');
  input.type = 'file';
  input.accept = "application/json";
  input.onchange = e => {
    let file = e.target.files[0];
    let reader = new FileReader();
    reader.onload = ev => {
      paths = JSON.parse(ev.target.result);
      redraw();
    };
    reader.readAsText(file);
  };
  input.click();
});

// Ù…Ø³Ø­
document.getElementById('clear').addEventListener('click', () => {
  paths = [];
  redraw();
});
</script>

</body>
</html>
